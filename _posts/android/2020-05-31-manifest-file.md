---
author: melissa
categories:
- Android
- Theory
date: "2020-05-31T21:00:00Z"
tags:
- android
- theory
- manifest
title: Манифест приложения
---

Манифест - это набор правил, по которым работает приложение.
Файл манифеста находится в корневой папке - `AndroidManifest.xml` - и содержит
важную информацию, без которой система не сможет запустить приложение.

**Основное содержимое манифеста:**
- Имя пакета для приложения. Является идентификатором приложения.
- Описание возможностей компонентов приложения: Activity, Service, Broadcast
  Receiver.
- Процессы, в которых будут запускаться компоненты приложения.
- Разрешения, которые необходимо запросить у пользователя, чтобы у приложения
  был доступ к защищенным частям API, а также чтобы другие приложения могли
  обращаться к вашему приложению.
- Содержит список классов Instrumentation, которые при выполнении приложения
  предоставляют сведения о профиле и прочую информацию. Эти объявления
  присутствуют в файле манифеста только во время разработки и отладки приложения
  и удаляются перед его публикацией.
- Объявляет минимальный уровень API Android, необходимый для работы приложения.
- Перечисляет связанные библиотеки.

**Основные правила манифеста:**
- Обязательно надо указать в манифесте два тега: `<manifest>` и `<application>`.
  Оба можно указать только один раз.
- Большинство тегов можно указывать несколько раз или не указывать совсем. Это
  зависит от того, что будет делать приложение. 
- Тег `<activity-alias>` должен следовать за тегом своей `<activity>`. Но многие
  теги одного уровня могут следовать в любом порядке. 
- Все значения задаются только в виде атрибутов. Некоторые атрибуты надо
  прописывать обязательно, некоторые ‒ нет. Если атрибут не прописан ‒
  используется значение по умолчанию. 
- Большинство атрибутов должны начинаться с префикса `android`. Только некоторые
  атрибуты тега `manifest` могут не иметь этого префикса.
- Многие элементы соответствуют объектам Java. Например, если вы указываете имя
  для `activity` с помощью атрибута `name`, то в состав имени должно входить полное
  обозначение пакета.
- Если элементу нужно указать несколько значений, то он всегда приводится
  повторно, вместо перечисления нескольких значений в одном элементе.

***

## Структура файла

Ниже представлена структура манифеста со всеми возможными элементами. А далее
рассмотрим каждый элемент отдельно. Для быстрого перехода к интересующему
элементу кликайте по содержанию справа.

```
<?xml version="1.0" encoding="utf-8"?>

<manifest>

    <uses-permission />
    <permission />
    <permission-tree />
    <permission-group />
    <instrumentation />
    <uses-sdk />
    <uses-configuration />  
    <uses-feature />  
    <supports-screens />  
    <compatible-screens />  
    <supports-gl-texture />  

    <application>

        <activity>
            <intent-filter>
                <action />
                <category />
                <data />
            </intent-filter>
            <meta-data />
        </activity>

        <activity-alias>
            <intent-filter> . . . </intent-filter>
            <meta-data />
        </activity-alias>

        <service>
            <intent-filter> . . . </intent-filter>
            <meta-data/>
        </service>

        <receiver>
            <intent-filter> . . . </intent-filter>
            <meta-data />
        </receiver>

        <provider>
            <grant-uri-permission />
            <meta-data />
            <path-permission />
        </provider>

        <uses-library />

    </application>

</manifest>
```

### `<?xml version="1.0" encoding="utf-8"?>`
Пространство имен Android, оно всегда одно и то же.

***

### `<manifest>`
Корневой элемент манифеста. Является обязательным.

***

### `<uses-permission>`
Разрешения, которые должны быть запрошены при установке приложения для его
нормального функционирования.

В некоторых случаях данные разрешения могут повлиять на фильтрацию вашего
приложения в Google Play. Например, если вы запрашиваете разрешение на
использование камеры, то Google Play логично предположит, что для работы
вашего приложения необходима камера и будет фильтровать устройства, на которых
ее нет. Чтобы корректно управлять данной фильтрацией, нужно использовать
`<uses-feature>`.

**Атрибуты:**
- `android:name` - имя разрешения. Это может быть разрешение, определенное в
  элементе `<permission>` данного приложения, разрешение, определенное в другом
  приложении или одно из стандартных системных разрешений.
- `android:maxSdkVersion` - самый высокий уровень API, на котором это
  разрешение должно быть предоставлено вашему приложению. Полезно использовать,
  когда с определенного уровня API запрашивать разрешение больше не требуется.

***

### `<permission>`
Разрешения, которые должны запросить другие приложения для получения доступа к
вашему приложению. Можно использовать существующие, либо создать собственные.

**Атрибуты:**  
- `android:name` - имя разрешения, будет использоваться в коде для ссылки на
  разрешение. Имена должны быть уникальными, так как если имя вашего разрешения
  совпадёт с именем разрешения другого приложения (которое уже установлено
    пользователем), то система не разрешит пользователю установить ваше приложение.
- `android:label` - имя разрешения, отображаемое пользователю.
- `android:description` - описание, которое должно объяснять пользователю для
  чего текущее разрешение требуется.
- `android:icon` - иконка разрешения.
- `android:permissionGroup` - определяет принадлежность к группе разрешений.
  Значением этого атрибута является имя группы, которое должно быть объявлено
  в элементе `<permission-group>` (в вашем или другом приложении).
- `android:protectionLevel` - уровень защиты, который говорит системе, как она
  должна себя вести, если текущее разрешение было кем-то запрошено. У данного
  атрибута может быть много значений, подробнее в [документации](https://developer.android.com/reference/android/R.attr?hl=ru#protectionLevel "developer.android.com").

  ***

### `<permission-tree>`
Элемент позволяет приложению объявлять пространство имён разрешений, в которое
оно может динамически во время выполнения добавлять новые разрешения.

**Атрибуты:**
- `android:icon` - иконка, которая будет отображаться для всех разрешений в
  дереве.
- `android:label` - имя группы (дерева разрешений).
- `android:name` - имя, которое будет добавляться как префикс всем разрешениям
  в древе. Должно быть уникальным, для этого рекомендуется, чтобы оно содержало
  более двух сегментов, разделенных точками.

***

### `<permission-group>`
Объявляет имя категории, в которую можно сгруппировать все логически связанные
разрешения. Добавить разрешение в группу можно с помощью атрибута
`permissionGroup` элемента `<permission>`. Разрешения из одной группы в
пользовательском интерфейсе отображаются вместе.

**Атрибуты:**  
- `android:description` - описание группы, отображаемое пользователю. Должно
  быть полным и понятным.
- `android:icon` - иконка.
- `android:label` - имя группы, отображаемое пользователю.
- `android:name` - имя группы, которое используется в коде для назначения
  категории атрибуту `permissionGroup` элемента `<permission>`.

***

### `<instrumentation>`
Объявляет класс [Instrumentation](https://developer.android.com/reference/android/app/Instrumentation?hl=ru "developer.android.com"), который дает возможность отслеживать все
взаимодействия, которые система выполняет с приложением. Обычно используется при
отладке и тестировании приложения и удаляется из release-версии приложения.

**Атрибуты:**
- `android:functionalTest` - если `true` - класс `Instrumentation` будет работать как
  функциональный тест, если `false` - нет.
- `android:handleProfiling` - будет ли класс `Instrumentation` включать / выключать
  профилирование. `True` - будет включать / выключать, при этом позволяет
  нацеливаться на определенный набор операций, `false` - профилирование будет
  выполняться все время.
- `android:icon` - иконка, которая будет присвоена классу `Instrumentation`.
- `android:label` - заголовок для класса `Instrumentation`.
- `android:name` - полное имя класса, который реализует `Instrumentation`.
- `android:targetPackage` - приложение, с которым будет работать объект
  `Instrumentation`. Приложение идентифицируется по имени пакета, назначенному
  в его файле манифеста.
- `android:targetProcesses` - процессы, с которыми будет работать объект
  `Instrumentation`. Можно перечислить через запятую или указать `"*"` для
  взаимодействия со всеми процессами, которые заданы атрибутом
  `android:targetPackage`.

***

### `<uses-sdk>`
Совместимость приложения с указанной версией Android. Когда приложение
будет устанавливаться, система сравнит указанный уровень API с API устройства.
Также Google Play использует этот элемент, чтобы отфильтровывать устройства,
которые не соответствуют указанному уровню API.

**Атрибуты:**
- `android:minSdkVersion` - минимальный уровень API, необходимый для работы
  приложения. Если значение не указать, то система будет думать, что ваше
  приложение поддерживает все уровни API. Поэтому этому атрибуту обязательно
  нужно задавать значение.
- `android:targetSdkVersion` - максимальный уровень API, под который приложение
  тестировалось. Этот атрибут помогает системе понять, можно ли использовать
  свежий функционал в приложении или оно может оказаться к нему не готовым.
  Помогает избежать ситуаций, когда после обновления версии API поменялись
  какие-либо ключевые значения от чего приложение может работать некорректно.
- `android:maxSdkVersion` - максимальный уровень API, который будет
  поддерживаться приложением. Если значение будет меньше, чем уровень API
  устройства, то система не позволит установить приложение. Если приложение
  было установлено, но позже устройство было обновлено до более высокого уровня
  API, чем указанный, то приложение перестанет отображаться, что фактически
  приравнивается к удалению приложения с устройства. Поэтому этот атрибут
  рекомендуется не указывать.

***

### `<uses-configuration>`
Требуемая для приложения аппаратная и программная конфигурация устройства.
Например, можно указать, что для работы приложения требуется физическая
клавиатура. Таким образом можно избежать ситуаций, когда приложение будет
установлено на устройство, где оно не сможет работать. Как правильно без этого
элемента можно обойтись и его даже не рекомендуют использовать, потому что
приложение должно стремится к универсальности и совместимости на большинстве
устройствах, а некоторые ограничения можно указать с помощью других атрибутов
(менее жестких в плане ограничения устройств).

**Атрибуты:**
- `android:reqFiveWayNav` - если `true`, то приложению требуется устройство ввода,
  поддерживающее навигацию вверх, вниз, влево, вправо, а также нажатие
  выделенного элемента. К таким устройствам относятся трекболы и D-pad.
  В принципе устарело.
- `android:reqHardKeyboard` - если `true`, то нужна аппаратная клавиатура.
- `android:reqKeyboardType` - позволяет задать тип клавиатуры. Варианты:
  - `undefined` - требование к наличию клавиатуры не определено.
  - `nokeys` - приложению не требуется клавиатура.
  - `qwerty` - требуется стандартная QWERTY-клавиатура.
  - `twelvekey` - требуется клавиатура, состоящая из цифр и знаков звёздочки
      `(*)` и решетки `(#)`.
- `android:reqNavigation` - позволяет указать, какое навигационное устройство
  требуется приложению. Варианты:
  - `undefined` - требование к навигации не определено.
  - `nonav` - навигационное устройство не требуется.
  - `dpad` - требуется [d-pad](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%B9%D0%BC%D0%BF%D0%B0%D0%B4 "wiki").
  - `trackball` - требуется [трекбол](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D0%BA%D0%B1%D0%BE%D0%BB "wiki").
  - `wheel` - требуется навигационное колесо (интересно, что это).
- `android:reqTouchScreen` - позволяет задать тип сенсорного экрана. Варианты:
  - `undefined` - требование не задано.
  - `notouch` - сенсорный экран не требуется.
  - `stylus` - требуется сенсорный экран, который управляется стилусом.
  - `finger` - требуется сенсорный экран, которым можно управлять пальцами.

***

### `<uses-feature> `
Объявляет одну или несколько аппаратных или программных функций, требуемых для
работы приложения.

**Атрибуты:**
- `android:name` - имя [аппаратной](https://developer.android.com/guide/topics/manifest/uses-feature-element?hl=ru#hw-features "developer.android.com") или [программной](https://developer.android.com/guide/topics/manifest/uses-feature-element?hl=ru#sw-features "developer.android.com") функции. Имена стандартные, чувствительны к регистру.
- `android:required` - если `true`, то приложение не может функционировать без функции, заданной атрибутом `name` элемента `<uses-feature> `.
- `android:glEsVersion` - версия `OpenGL ES`, требуемая для работы приложения.

***

### `<supports-screens> `
Позволяет указать размеры экрана, которые поддерживаются приложением.
Если размер экрана будет больше, чем поддерживается приложением, то включится
режим совместимости, что не очень хорошо, так как этот режим может вызвать
размытие интерфейса из-за неправильного масштабирования. Поэтому рекомендуется
создавать свои макеты под каждый размер экрана. Кроме того, с помощью отдельного
макета можно оптимизировать интерфейс, например, чтобы на экране отображалось
два окна (двупанельный интерфейс). Как поддерживать разные размеры
экранов описано документации [здесь](https://developer.android.com/guide/practices/screens_support?hl=ru "developer.android.com").

По умолчанию, для каждого атрибута установлено значение `true`, поэтому
используйте этот элемент, чтобы указать какие экраны вы **не поддерживаете**.

**Атрибуты:**
- `android:smallScreens`
- `android:normalScreens`
- `android:largeScreens`
- `android:xlargeScreens`
- `android:anyDensity`

**Данные атрибуты были добавлены в API 13 (Android 3.2):**
- `android:requiresSmallestWidthDp` - позволяет указать минимальную ширину
  экрана (наименьшая сторона устройства), чтобы Google Play отфильтровывал
  неподходящие устройства.
- `android:compatibleWidthLimitDp` - позволяет указать максимальную
  **наименьшую ширину экрана**. Если же значение превысит заданное, то
  пользователю будет предложено включить режим совместимости.
- `android:largestWidthLimitDp` - позволяет указать максимальную
  **наименьшую ширину экрана**. Если же значение превысит заданное, то будет
  принудительно включен режим совместимости без возможности отключения.

***

### `<compatible-screens>  `
Позволяет задать все возможные размеры экранов, с которыми совместимо приложение.
Данный элемент может быть указан в манифесте только один раз, зато внутри него
можно добавлять тег `<screen>` с указанием поддерживаемого размера экрана.

Этот элемент носит исключительно информационный характер. С помощью него Google
Play фильтрует устройства с неподдерживаемыми экранами.

Конфигурация экрана, которая не указана в этом элементе, считается
неподдерживаемой приложением.

Для тех же целей проще использовать элемент `<supports-screens>`, так как в
нем не нужно указывать конкретные размеры экранов, а достаточно выставить
логическое значение для нужного атрибута.

***

### `<supports-gl-texture> `
Определяет формат сжатия текстур GL. Элемент является информационным, т.е.
необходим Google Play для фильтрации устройств, которые не поддерживают заданные
параметры.

***

### `<application>`
Обязательный элемент манифеста, который содержит информацию о всех компонентах
приложения (activity, service, receiver, provider), а также атрибуты, которые
могут влиять на эти компоненты. В манифесте может быть только один элемент
`<application>`.

**Дочерние элементы:**
- `<activity>`
- `<activity-alias>`
- `<meta-data>`
- `<service>`
- `<receiver>`
- `<provider>`
- `<uses-library>`

**Атрибуты:**
- `android:allowTaskReparenting` - позволяет **activity** перемещаться из **task'а**,
  который ее запустил, в **task** переднего плана, с которым **activity** имеет общее
  `taskAffinity`-значение. Если атрибут задан в теге `<application>`, то оно
  применяется ко всем **activity**. Но можно задавать и для конкретной **activity**.
- `android:allowBackup` - позволяет указать будет ли выполняться резервное
  копирование приложения. По умолчанию `true`, если указать `false`, то
  приложение не будет обслуживаться сервисом [**Backup Manager**](https://developer.android.com/reference/android/app/backup/BackupManager "developer.android.com") - интерфейс,
  через который приложение запрашивает операции резервного копирования и
  восстановления.
- `android:allowClearUserData` - применимо только для системных приложений,
  для обычных приложений игнорируется. Позволяет приложению сбрасывать
  пользовательские данные.
- `android:allowNativeHeapPointerTagging` - вот, что я поняла, почитав про этот
  тег: он добавлен временно и позволяет отключить **Pointer Tagging**. Оставляю
  [ссылку](https://source.android.com/devices/tech/debug/tagged-pointers "source.android.com") на документацию, может поможет.
- `android:backupAgent` - следует использовать, если приложение выполняет
  резервное копирование. Значением данного атрибута является подкласс класса [`BackupAgent`](https://developer.android.com/reference/android/app/backup/BackupAgent "developer.android.com"), где указывается, что именно будет сохранено в облачном
  хранилище и восстановлено после реинсталляции приложения.
- `android:backupInForeground` - если значение `true`, то резервное копирование
  может производиться, когда приложение активно. Вообще система закрывает
  приложение, если идет резервное копирование, поэтому включение этого
  параметра может повлиять на работу приложения.
- `android:banner` - картинка, которая будет отображаться на главном экране
  Android TV. При использовании этого атрибута в элементе `<application>`,
  картинка применится ко всем компонентам приложения. Можно задать индивидуальную
  картинку для каждой `<activity>`. Актуально только при разработке приложения
  для Android TV.
  [Подробнее](https://developer.android.com/training/tv/start/start#banner "developer.android.com").
- `android:debuggable` - раньше этот тег использовался для того, чтобы
  запускать приложение в режиме отладки на реальном устройстве. На данный
  момент, если приложение запускает на реальном устройстве в режиме отладки,
  этот тег вставляется автоматически со значением `true` и также автоматически
  удаляется после завершения. В любом случае, этот тег нужно удалять из релизной
  версии.
- `android:description` - краткое описание приложения, отображаемое пользователю.
- `android:directBootAware` - включает режим **Direct Boot**, при котором
  приложение получает ограниченный доступ к файлам сразу после запуска системы,
  но до того, как пользователь разблокирует устройство. Может использоваться
  такими приложениями, как будильники, мессенджеры. Подробнее в [статье](https://android-developers.googleblog.com/2016/04/developing-for-direct-boot.html "android-developers.googleblog.com") из блога Google или в [документации](https://developer.android.com/training/articles/direct-boot "developer.android.com").
- `android:enabled` - если `false`, то система не может создавать экземпляры
  компонентов приложения. Не знаю какой смысл добавлять этот атрибут в элемент
  `<application>`, но его можно использовать для отключения конкретного
  дочернего компонента, если он не поддерживается какой-либо версией Android. [Пример](https://developer.android.com/guide/topics/providers/document-provider.html#manifest "developer.android.com").
- `android:extractNativeLibs` - если `true` (по умолчанию), то нативные
  библиотеки приложения будут храниться в сжатом виде в APK, а при установке
  извлекаться **PackageManager'ом** и помещаться в **/ data / app /**. При этом
  размер APK будет меньше, так как библиотеки сжаты. Но приложение будет дольше
  устанавливаться и занимать больше места в установленном виде.  
  Если `false` (по умолчание, если версия Gradle 3.6.0 и выше), то нативные
  библиотеки будут хранится в APK в несжатом виде. Размер APK увеличится, но и
  занимаемое после установки пространство уменьшится. [Подробнее](https://stackoverflow.com/a/44704840/13626164 "stackoverflow.com").
- `android:fullBackupContent`- значением атрибута является ссылка на `xml` файл,
  в котором содержатся правила для автоматического резервного копирования.
  Подробнее о том, как оформлять файл, можно почитать
  [здесь](https://developer.android.com/guide/topics/data/autobackup#IncludingFiles "developer.android.com").
  Этот атрибут не является обязательным, так как большинство файлов приложения
   и так включено в автоматическое резервное копирование.
   [Здесь](https://developer.android.com/guide/topics/data/autobackup#Files "developer.android.com") перечислены эти файлы.
- `android:fullBackupOnly` - данный атрибут используется, если в приложении
  реализован кастомный [BackupAgent](https://developer.android.com/guide/topics/data/autobackup#ImplementingBackupAgent "developer.android.com"). В этом случае
  присваивается значение `true` - будет использовано автоматическое резервное
  копирование вместо [`key/value`](https://developer.android.com/guide/topics/data/keyvaluebackup "developer.android.com").
- `android:gwpAsanMode` - указывает следует ли использовать [GWP-ASan](https://developer.android.com/ndk/guides/gwp-asan "developer.android.com") - анализатор
  памяти, который позволяет находить и исправлять проблемы, вызванные
  небезопасной работой с памятью.
- `android:hasCode` - если приложение не содержит Java-кода, а полностью
  реализовано на основе программного интерфейса NDK API, то данного атрибуту
  необходимо установить значение `false`.
- `android:hasFragileUserData` - если `true`, то когда пользователь будет
  удалять приложение, ему будет предложено сохранить данные приложения.
- `android:hardwareAccelerated` - включает аппаратное ускорение для всего
  приложения. Если minSDK или targetSDK больше или равно 14, то значение по умолчанию
  `true`. [Подробнее](https://developer.android.com/guide/topics/graphics/hardware-accel "developer.android.com").
- `android:icon` - иконка для всего приложения. Если данный атрибут использовать
  внутри, например, **activity**, то у этой **activity** будет персональная иконка.
- `android:isGame` - является ли приложение игрой. Нужен системе для сортировки
  и группировки всех игр вместе.
- `android:killAfterRestore` - используется системными приложениями, пока не
  ясно с какой целью.
- `android:largeHeap` - используется, если приложению может понадобится
  расширение размера кучи.
- `android:label` - название приложения, отображаемое пользователю.
- `android:logo` - логотип приложения.
- `android:manageSpaceActivity` - когда мы просматриваем приложения через
  системные настройки, можно заметить, что у некоторых приложений (как правило
  системных) вместо кнопки "Очистить кэш" есть кнопка "Управление памятью"
  (или вроде того). При нажатии на эту кнопку открывается другое окно, в котором
  можно выбрать, какие именно данные удалить. Такую функцию можно добавить к
  любому приложению с помощью этого атрибута. Значением атрибута является имя
  подкласса **activity**, которую система должна запустить при нажатии на эту кнопку.
- `android:name` - имя подкласса **Application**. Зачем этот атрибут добавлять пока
  непонятно.
- `android:networkSecurityConfig` - задается имя `xml`-файла, который содержит
  конфигурацию [сетевой безопасности](https://developer.android.com/training/articles/security-config "developer.android.com").
- `android:permission` - имя разрешения, которое должно быть предоставлено для
  использования приложения. Применяется ко всем компонентам приложения.
- `android:persistent` - в документации неявно сформулировано, что данный
  атрибут могут использовать только системные приложения. Если приложение не
  является системным, то атрибут игнорируется. А предназначение атрибута
  следующее - позволяет запускать фоновую службу и предотвращать ее
  автоматическое уничтожение. Взято [отсюда](https://stackoverflow.com/a/58612987/13626164 "stackoverflow.com").
- `android:process` - позволяет указать процесс, в котором будет работать
  приложение. По умолчанию имя процесса соответствует имени пакета, заданного
  в теге `<manifest>`. Можно использовать для запуска компонентов двух приложений
  в одном процессе, но при условии, что оба приложения подписаны одним
  сертификатом. Если данному атрибуту было присвоено имя, которое начинается с
  двоеточия, то создается приватный процесс конкретно для этого приложения. Если
  же имя начинается с маленькой буквы, то создается глобальный процесс, который
  можно использовать совместно с другими приложениями.
- `android:restoreAnyVersion` - если `true`, то **BackupManager** будет пытаться
  восстановить данные приложения из облачного хранилища, даже если текущая
  версия приложения не совпадает с версией, которая выполняла резервное
  копирование, что в свою очередь может указывать на несовместимость данных.
- `android:requestLegacyExternalStorage` - атрибут добавлен относительно недавно
  в связи с тем, что в Android 10 приложениям запретили неограниченное обращение
  к файлам в хранилище и, если я правильно поняла, этот тег позволяет обойти эту
  защиту. Тем не менее решение временно, просто дали время для внесения изменений.
- `android:requiredAccountType` - можно задать тип учетной записи, которая
  требуется для работы приложения (например, com.google).
- `resizeableActivity` - поддерживает ли приложение многооконный режим. Можно
  задать для конкретной **activity**. Если target API 24 и выше, то значение
  по умолчанию = `true`.
- `android:restrictedAccountType` - позволяет указать, что ограниченным
  профилям разрешен доступ к основной учетной записи. Ограниченные профили
  были введены для совместной работы с одной учетной записи, но с некоторыми
  ограничениями (без доступа к почте, игровому магазину, календарю итд.).
- `android:supportsRtl` - если `true` и `targetSdkVersion` - 17 и выше, то
  приложение будет поддерживать макеты "справа налево".
- `android:taskAffinity` - указывается имя **task'а**. Позволяет изменять поведение
  **activity**, например, чтобы в одном приложении **activity** работали в разных
  **task'ах** или **activity** разных приложений работал в одном. Данный атрибут
  будет работать при следующих обстоятельствах:
  - **Intent**, который запускает **activity**, содержит флаг `FLAG_ACTIVITY_NEW_TASK`.
  - У запускаемой **activity** установлен атрибут `allowTaskReparenting = true`.
  Атрибут означает, что **activity** может перемещаться между **task'ом**, который
  ее вызвал, и **task'ом**, который указан в `taskAfinity` - в зависимости от
  того, какой **task** сейчас активен.
- `android:testOnly` - с помощью этого атрибута, можно указать, что текущее
  приложение только для целей тестирования. Такое приложение можно установить
  только через **adb (Android Debug Bridge)** и его нельзя опубликовать в Google
  Play.
- `android:theme` - устанавливает тему для всего приложения (указывается ссылка
  на ресурс типа `style.xml`). Компоненты приложения могут переопределить этот
  атрибут и задать свои значения.
- `android:uiOptions` - позволяет разделить **actionBar** на 2 части, если в нем
  слишком много элементов. Например, при горизонтальной ориентации в **actionBar'е**
  места много, все элементы умещаются и он выглядит как обычно. Но при
  вертикальной он может разделиться на 2 части - верхнюю и нижнюю. В верхней
  части останется заголовок и иконка, а в нижнюю переместятся элементы меню.
  Можно указывать для конкретной **activity**.
- `android:usesCleartextTraffic` - данный атрибут позволяет обойти запрет на
  отправку запросов без шифрования (http вместо https).
- `android:vmSafeMode` - если `true`, то отключает ART [AOT-компилятор](https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F "wiki").

***

### `<activity>`
Объявляет **activity**. Каждая **activity** объявляется отдельным элементом
`<activity>`. Если **activity** не будет добавлена в манифест, то система ее
не увидит и не сможет запустить. Данный тег обязательно должен находится внутри
элемента `<application>`.

**Дочерние элементы:**
- `<intent-filter>`
- `<meta-data>`
- `<layout>`

**Атрибуты:**
- `android:allowEmbedded` - указывает, что **activity** может быть запущена как
  вложенный дочерний элемент другой **activity**. Например, это может понадобится
  при внедрении в приложение **Bubbles** и при разработки для Android Wear.
- `android:allowTaskReparenting` - позволяет **activity** перемещаться из **task'а**,
  который ее запустил, в **task** переднего плана, с которым **activity** имеет общее
  `taskAffinity`-значение.
- `android:alwaysRetainTaskState` - если значение этого атрибута для корневой
  **activity** = `true`, то стек не будет чиститься и полностью восстановится
  даже после длительного времени. Атрибут есть смысл указывать только для корневой
  **activity**, так как для всех остальных заданное значение будет игнорироваться.
- `android:autoRemoveFromRecents` - если данный атрибут задать нескольким
  **activity** и если эти **activity** будут запущены пользователем, то они поместятся
  в один **task**, который будет находится на экране до тех пор, пока пользователь
  не закроет последнюю **activity** в этом **task'е**. При этом **task** сам завершит
  свою работу, так сказать самоликвидируется. Атрибут отменяет действие флага [`FLAG_ACTIVITY_RETAIN_IN_RECENTS`](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS "developer.android.com").
- `android:banner` - картинка, которая будет отображаться на главном экране
  Android TV. При использовании этого атрибута в элементе `<application>`,
  картинка применится ко всем компонентам приложения. Можно задать индивидуальную
  картинку для каждой `<activity>`. Актуально только при разработке приложения
  для Android TV.
- `android:clearTaskOnLaunch` - если значение этого атрибута для корневой
  **activity** = `true`, то **back stack** будет чиститься моментально, как только
  пользователь покинет **task**. Полная противоположность `alwaysRetainTaskState`.
- `android:colorMode` - отображение **activity** в режиме широкой цветовой гаммы
  (для отображения более ярких цветов). Если устройство не поддерживает такой
  режим, то атрибут игнорируется.
- `android:configChanges`- в данном атрибуте можно перечислить, какие изменения
  в конфигурации **activity** будут игнорироваться, т.е. данные изменения в
  конфигурации не будут вести к пересозданию **activity**. Вместо этого **activity**
  вызовет метод `onConfigurationChanged()`. Использование данного атрибуты
  считается плохим тоном, так как изменения в конфигурации никак не
  обрабатываются. Данный атрибут можно спокойно использовать, если в приложении
  все ресурсы (макеты, картинки итд.) для всех ориентаций экрана одинаковы.
- `android:directBootAware` - включает режим **Direct Boot**, при котором
  конкретная **activity** получает ограниченный доступ к файлам сразу после запуска
  системы,но до того, как пользователь разблокирует устройство. Может использоваться
  такими приложениями, как будильники, мессенджеры. Подробнее в [статье](https://android-developers.googleblog.com/2016/04/developing-for-direct-boot.html "android-developers.googleblog.com") из блога Google или в [документации](https://developer.android.com/training/articles/direct-boot "developer.android.com").
- `android:documentLaunchMode` - позволяет указать каким образом новый экземпляр
  **activity** будет добавляться в **task**. Например, на экране обзора **task'ов**
  могут быть отображены несколько документов из одного приложения. [Подробнее](https://developer.android.com/guide/components/recents "developer.android.com").
- `android:enabled` - если `false`, то система не может создавать экземпляр
  **activity**. Можно использовать для отключения **activity**, которая не
  поддерживается какой-либо версией Android (хотя конкретный пример использования
  сложно представить).
- `android:excludeFromRecents` - если `true`, а также если атрибут задан
  для корневой **activity**, то **task** не будет отображаться на обзорном экране
  последних запущенный приложений. [Подробнее](https://developer.android.com/guide/components/recents "developer.android.com").
- `android:exported` - если `true`, то **activity** может быть запущена
  компонентами других приложений, если `false` - **activity** может быть запущена
  только компонентами одного и того же приложения, либо приложениями с одинаковыми идентификаторами пользователя. В любом случае для запуска **activity** нужно знать
  ее точное имя класса.
- `android:finishOnTaskLaunch` - атрибут похож на `clearTaskOnLaunch`, но в
  отличии от него из **task'а** будет удалена та **activity**, для которой значение
  этого атрибута = **true**. Т.е. **activity** будет частью **task'а** только для
  текущего сеанса и если пользователь свернет **task**,  то **activity** будет из
  него удалена.
- `android:hardwareAccelerated` - включает аппаратное ускорение для текущей
  **activity**.  [Подробнее](https://developer.android.com/guide/topics/graphics/hardware-accel "developer.android.com").
- `android:icon` - иконка для текущей **activity**.
- `android:immersive` - включает режим погружения, в котором приложение
  отображается на весь экран, скрывая системные панели и панель навигации.
  Для того, чтобы увидеть эти панели пользователю нужно свайпнуть от верхнего
  или нижнего края экрана к центру.
- `android:label` - заголовок **activity**, отображаемый пользователю. Если не
  задан, то используется заголовок, установленный в элементе `<application>`.
- `android:launchMode` - данный атрибут можно указать для каждой **activity**
  в манифесте. Имеет несколько значений:
	- `standard` - при запуске **activity** создается новый экземпляр в стеке.
  	**Activity** может размещаться в стеке несколько раз.
	- `singleTop` - **activity** может располагаться в стеке несколько раз. Новая
  	запись в стеке создается только в том случаи, если данная **activity** не
    расположена в вершине стека. Если она на данный момент является вершиной,
    то у нее сработает `onNewIntent()` метод, но она не будет пересоздана.
	- `singleTask` - создает новый **task** и устанавливает **activity** корневой
  	для него, но только в случае, если экземпляра данной **activity** нет ни в
    одном другом **task'е**. Если **activity** уже расположена в каком либо **task'е**,
    то откроется именно тот экземпляр и вызовется метод `onNewIntent()`. Она в
    свое время становится главной, и все верхние экземпляры удаляются, если они
    есть. При этом, если **activity** была вытащена из **task'а** в бэкграунде, то
    мы переключимся на этот **task** и его стек. Только один экземпляр такой
    **activity** может существовать.
	- `singleInstance` - тоже что и `singleTask`, но для данной **activity** всегда
  	будет создаваться отдельный **task** и она будет в ней корневой. Данный флаг
    указывает, что **activity** будет одним и единственным членом своего **task'а**.
- `android:lockTaskMode` - определяет, как система будет отображать
  **activity** в режиме блокировки задач (lock task mode). Подробнее о режиме [здесь](https://developer.android.com/work/dpc/dedicated-devices/lock-task-mode "developer.android.com").
  Возможные значения:
  - `normal` - значение по умолчанию. **Task'и** могут быть добавлены только с
    помощью метода `startLockTask()`.
  - `never` - этот режим доступен только для системных приложений, для всех
    остальных игнорируется. В этом режиме **task'и** не запускаются и пользователь
    не может их закрепить на обзорном экране.
  - `if_whitelisted` - если **activity** прошла авторизацию у
    **Device Policy Controller**, то применяется значение `always`, если не прошла -
    `normal`.
  - `always` - режим доступен только для системных приложений.
- `android:maxRecents` - указывается максимальное количество **task'ов**, в
  которых может быть запущена эта **activity**. Если значение было превышено, то
  система начнет удалять **task'и**. По умолчанию - 16, максимальное количество -
  50 (25 на устройствах с низким объемом памяти). Значение не может быть нулевым.
- `android:maxAspectRatio` - максимальное соотношение сторон, которое
  поддерживает  приложение. Получается путем деления длинной стороны на короткую.
  Атрибут игнорируется, если задан атрибут `resizeableActivity = true`,  так как
  это означает, что **activity** поддерживает любой размер экрана.
- `android:multiprocess` - если `true`, то **activity** будет запускаться в новом процессе. На [stackoverflow](https://stackoverflow.com/a/38991613/13626164 "stackoverflow.com") пишут,
  что надо забыть о существовании этого атрибута.
- `android:name` - полное имя класса, который реализует **activity**.
- `android:noHistory` - если `true`, то к остановленной **activity** нельзя
  вернуться, так как она удаляется из стека. Удобно использовать, если при
  запуске приложения нужно показать лого и больше к нему не возвращаться.
- `android:parentActivityName` - указывается имя класса **activity**, которая
  будет открыта, если пользователь нажмет на стрелку "UP". Например, данному
  атрибуту задано значение `MainActivity`, а пользователь находится в
  `SettingsActivity`. В этом случае, если он нажмет на стрелку "UP", будет открыта
  `MainActivity`.
- `android:persistableMode` - можно указать, в каком виде будет сохранена
  **activity** в **task'е** при перезагрузке устройства. Если корневая **activity** в
  **task'е** устанавливает данному атрибуту значение `persistRootOnly`, то
  сохраняется только корневая **activity**. Иначе будут сохранены все **activity**,
  которым в данном атрибуте задано значение `persistAcrossReboots`.
- `android:permission` - имя разрешения, которое должно быть предоставлено для
  запуска **activity** или для получения от **activity** какой-либо информации.
- `android:process` - позволяет указать процесс, в котором будет работать **activity**.
  По умолчанию имя процесса соответствует имени пакета, заданного в теге `<manifest>`.
  Но можно переопределить этот атрибут и распределить компоненты приложения по
  нескольким процессам.
- `android:relinquishTaskIdentity` - ...
- `resizeableActivity` - может ли пользователь запустить данную **activity** в
  многооконном режиме. Если target API 24 и выше, то значение по умолчанию = `true`.
- `android:screenOrientation` - в какой ориентации будет отображаться **activity**
  на экране. Атрибут игнорируется, если приложение запущено в многооконном режиме.
  Все возможные значения [здесь](https://developer.android.com/guide/topics/manifest/activity-element#screen "developer.android.com").
- `android:showForAllUsers` - отображается ли **activity**, если текущий
  пользователь отличается от пользователя, который ее запустил.
- `android:stateNotNeeded` - позволяет перезапустить **activity** без сохранения
  ее состояния. Т.е. при перезапуске не будет вызван метод `onSaveInstanceState()`,
  а в `onCreate()` будет передано значение `NULL`. Например, можно использовать
  для стартового экрана, чтобы избежать удаления из-за какого-либо сбоя.
- `supportsPictureInPicture` - поддерживает ли **activity** режим ["картинка в картинке"](https://developer.android.com/guide/topics/ui/picture-in-picture "developer.android.com").
  Это такой многооконный режим, в основном предназначенный для просмотра видео.
  Позволяет пользователю смотреть видео в маленьком окошке в углу экрана и
  одновременно переключаться и работать с другими приложениями.
- `android:taskAffinity` - устанавливается имя **task'а**. Используется для
  группировки **activity**, например, чтобы в одном приложении **activity** работали
  в разных **task'ах** или **activity** разных приложений работал в одном. Данный
  атрибут будет работать при следующих обстоятельствах:
  - **Intent**, который запускает **activity**, содержит флаг `FLAG_ACTIVITY_NEW_TASK`.
  - У запускаемой **activity** установлен атрибут `allowTaskReparenting = true`.
  Атрибут означает, что **activity** может перемещаться между **task'ом**, который
  ее вызвал, и **task'ом**, который указан в `taskAfinity` - в зависимости от
  того, какой **task** сейчас активен.
- `android:theme` - указывается ссылка на тему **activity**. Если данный атрибут
  не задан, то наследуется от одноименного атрибута в элементе `<application>`.
  Если и он не задан, то используется системная тема.
- `android:uiOptions` - позволяет разделить **actionBar** на 2 части, если в нем
  слишком много элементов. Например, при горизонтальной ориентации в **actionBar'е**
  места много, все элементы умещаются и он выглядит как обычно. Но при
  вертикальной он может разделиться на 2 части - верхнюю и нижнюю. В верхней
  части останется заголовок и иконка, а в нижнюю переместятся элементы меню.
- `android:windowSoftInputMode` - указывается, как **activity** взаимодействует
  с экранной клавиатурой. Например, можно уменьшить окно, чтобы клавиатура
  поместилась или просто сдвинуть содержимое окна, тем самым освободив место для
  клавиатуры. Можно указывать несколько значений, разделяя их вертикальной
  линией `|`. Со всеми значениями можно ознакомиться [здесь](https://developer.android.com/guide/topics/manifest/activity-element#wsoft "developer.android.com").

  ***

### `<activity-alias>`
Данный элемент задает **activity** псевдоним и в манифесте должен следовать
сразу после этой activity. Данный тег обязательно должен находится внутри
элемента `<application>`.

Когда мы разрабатываем приложение, то периодически можем менять названия классов,
изменять **activity**, которая будет запускаться первой итд. И вроде ничего в этом
страшного нет, но пользователя может смутить, например, исчезновения иконки
приложения с главного экрана (потому что мы ранее изменили имя стартовой **activity**).
Чтобы этого избежать используется данный элемент. Т.е. мы можем стартовой
**activity** присвоить псевдоним и при запуске приложения система будет
осуществлять поиск этой **activity** именно по псевдониму, а не по имени класса,
который ее реализует. И если мы назначим стартовой другую **activity**, то
пользователь уже не потеряет иконку на главном экране, так как псевдоним
остался без изменений.

На эту тему есть интересная [статья](https://blog.mindorks.com/understanding-activity-aliases-in-android-to-preserve-your-launchers "blog.mindorks.com").

**Дочерние элементы:**
- `<intent-filter>`
- `<meta-data>`

**Атрибуты:**
- `android:enabled=["true" | "false"]` - если `false`, то система не может создавать
  экземпляр **activity**, для которой создан данный псевдоним.
- `android:exported=["true" | "false"]`- если `true`, то **activity** может быть
  запущена под псевдонимом компонентами других приложений, если `false` - **activity**
  может быть запущена под псевдоним только компонентами одного и того же приложения,
  либо приложениями с одинаковыми идентификаторами пользователя. При этом если у
  элемента `<activity-alias>` отсутствуют intent-фильтры, то значение по
  умолчанию = `false` (так как подразумевается, что псевдоним предназначен для
  использования внутри приложения), если intent-фильтры заданы, то значение по
  умолчанию = `true`.
- `android:icon="drawable resource"` - иконка, которая будет отображаться
  пользователю во время работы с **activity**, запущенной по данному псевдониму.
- `android:label="string resource"` - заголовок, который будет отображаться
  пользователю во время работы с **activity**, запущенной по данному псевдониму.
- `android:name="string"` - имя псевдонима. Имя указывается произвольное, должно
  быть уникальным, но не должно ссылаться на существующий класс.
- `android:permission="string"` - имя разрешения, которое должно быть
  предоставлено для запуска **activity** под данным псевдонимом или для получения
  от **activity** какой-либо информации.
- `android:targetActivity="string"` - полное имя класса, который реализует
  **activity** и должен быть запущен через данный псевдоним. Имя, указанное в
  данном атрибуте, должно соответствовать имени, указанному в атрибуте
  `android:name` элемента `<activity>`, за которым в манифесте следует псевдоним.

***

### `<meta-data>`
Данный элемент позволяет записать какие-либо данные по типу "ключ-значение".
Доступ к этим данным можно получить из всего приложения (если объявлены в внутри
тега `<application>`), либо можно передать необходимые для работы данные
конкретной **activity** (объявляется внутри тега `<activity>`).

Количество элементов `<meta-data>` неограничено. Все их значения в итоге будут
собраны в один объект **Bundle**, а получить эти значения можно с помощью
`PackageItemInfo.metaData`.

Например, в приложении используются уникальные шрифты. Чтобы избежать задержек
при запуске приложения, хотелось бы загружать их предварительно. Для этого создается
файл в ресурсах, в котором перечисляются эти шрифты:

```
// preloaded-fonts.xml

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="preloaded_fonts" translatable="false">
        <item>@font/lato</item>
        <item>@font/lato_bold</item>
    </array>
</resources>
```

После чего ссылка на этот файл указывается в мета-данных манифеста:

```
<meta-data
    android:name="preloaded_fonts"
    android:resource="@array/preloaded_fonts"/>
```

**Может быть дочерним элементом для:**
- `<activity>`
- `<activity-alias>`
- `<application>`
- `<provider>`
- `<receiver>`
- `<service>`

**Атрибуты:**
- `android:name="string"` - имя мета-данных. Должно быть уникальным, поэтому
  рекомендуется в качестве префикса использовать полное имя пакета, например, `com.example.project.preloaded_fonts`.
- `android:resource="resource specification"` - ссылка на xml-файл в ресурсах,
  где хранится значение элемента.
- `android:value="string"` - значение элементу можно присваивать напрямую с помощью
  данного атрибута. Возможные типы данных - String, Int, Boolean, Color (в виде
  `#rgb, #argb, #rrggbb, #aarrggbb`), Float.

***

### `<service>`
С помощью данного элемента объявляется **service** как один из компонентов
приложения. У **service'ов** нет визуального интерфейса, а используются они для
выполнения каких-либо фоновых задач. Также как и **activity**, все **service'ы**
должны быть объявлены в манифесте, иначе система их никогда не запустит.

Данный тег обязательно должен находится внутри элемента `<application>`.

**Дочерние элементы:**
- `<intent-filter>`
- `<meta-data>`

**Атрибуты:**
- `android:description="string resource"` - небольшое описание о предназначении
  **service'а**, которое отображается пользователю.
- `android:directBootAware=["true" | "false"]` - включает режим **Direct Boot**,
  при котором конкретный **service** получает ограниченный доступ к файлам сразу
  после запуска системы, но до того, как пользователь разблокирует устройство.
  Может использоваться такими приложениями, как будильники, мессенджеры.
  Подробнее в [статье](https://android-developers.googleblog.com/2016/04/developing-for-direct-boot.html "android-developers.googleblog.com") из блога Google или в
  [документации](https://developer.android.com/training/articles/direct-boot "developer.android.com").
- `android:enabled=["true" | "false"]` - если `false`, то система не может
  создавать экземпляр **service'а**. Можно использовать для отключения **service'ов**,
  которые не поддерживается какой-либо версией Android (хотя конкретный пример
  использования сложно представить).
- `android:exported=["true" | "false"]` - если `true`, то **service** может быть
  запущен компонентами других приложений, если `false` - **service** может быть
  запущен только компонентами одного и того же приложения, либо приложениями с
  одинаковыми идентификаторами пользователя.
- `android:foregroundServiceType=["connectedDevice" | "dataSync" | "location" |
  "mediaPlayback" | "mediaProjection" | "phoneCall" ]` - позволяет указать, что данный  **service** является **service'ом** [переднего плана](https://developer.android.com/guide/components/services#Types-of-services "developer.android.com") определенного типа.
- `android:icon="drawable resource"` - иконка для текущего **service'а**.
- `android:isolatedProcess=["true" | "false"]` - если true, то **service** будет
  запускаться в специальном процессе, который изолирован от остальной системы.
  Связаться с таким **service'ом** можно через **Service API**.
- `android:label="string resource"` - название **service'а**, которое отображается
  пользователю.
- `android:name="string"`- полное имя класса, который реализует **service**.
- `android:permission="string"` - имя разрешения, которое должно быть
  предоставлено для запуска **service'а** или для привязки к нему.
- `android:process="string"` - позволяет указать процесс, в котором будет работать
  **service**. По умолчанию имя процесса соответствует имени пакета, заданного в
  теге `<manifest>`. Но можно переопределить этот атрибут и распределить компоненты
  приложения по нескольким процессам.

***

### `<receiver>`
С помощью данного элемента объявляется **BroadcastReceiver** как один из компонентов
приложения. **BroadcastReceiver** позволяет прослушивать сообщения и события из
разных точек: из других приложений, из системы, из вашего приложения. Существует
два способа создания **BroadcastReceiver'а**: указать его в манифесте, либо
создавать динамически в коде и регистрировать с помощью метода
`Context.registerReceiver ()`. Т.е. необязательно все **BroadcastReceiver'ы**
указывать в манифесте.

Данный тег обязательно должен находится внутри элемента `<application>`.

**Дочерние элементы:**
- `<intent-filter>`
- `<meta-data>`

**Атрибуты:**
- `android:directBootAware=["true" | "false"]` - включает режим **Direct Boot**,
  при котором конкретный **receiver** получает ограниченный доступ к файлам сразу
  после запуска системы, но до того, как пользователь разблокирует устройство.
  Может использоваться такими приложениями, как будильники, мессенджеры.
  Подробнее в [статье](https://android-developers.googleblog.com/2016/04/developing-for-direct-boot.html "android-developers.googleblog.com") из блога Google или в
  [документации](https://developer.android.com/training/articles/direct-boot "developer.android.com").
- `android:enabled=["true" | "false"]` - если `false`, то система не может
  создавать экземпляр **receiver'а**. Можно использовать для отключения **receiver'ов**,
  которые не поддерживается какой-либо версией Android (хотя конкретный пример
  использования сложно представить).
- `android:exported=["true" | "false"]` - если `true`, то **receiver** может
  получать сообщения от других приложений, если `false` - **receiver** может
  получать сообщения только от компонентов одного и того же приложения, либо
  приложениями с одинаковыми идентификаторами пользователя.
- `android:icon="drawable resource"` - иконка для текущего **receiver'а**.
- `android:label="string resource"` - название **receiver'а**, которое отображается
  пользователю.
- `android:name="string"` - полное имя класса, который реализует **receiver**.
- `android:permission="string"` - имя разрешения, которое должно быть
  предоставлено для отправки сообщения **receiver'у.**
- `android:process="string"` - позволяет указать процесс, в котором будет работать
  **receiver**. По умолчанию имя процесса соответствует имени пакета, заданного в
  теге `<manifest>`. Но можно переопределить этот атрибут и распределить компоненты
  приложения по нескольким процессам.

***

### `<provider>`
С помощью данного элемента объявляется **ContentProvider** как один из компонентов
приложения. **ContentProvider** нужен только в том случае, если вам необходимо
обмениваться данными между несколькими приложениями. Например, данные контактов
используются многими приложениями, потому хранятся в **ContentProvider'е**.
[Подробнее](https://developer.android.com/guide/topics/providers/content-providers "developer.android.com").

В манифесте необходимо указывать все **ContentProvider'ы**, реализуемые в приложении.
Если в приложении используются **ContentProvider'ы** других приложений, то их
объявлять не требуется.

Данный тег обязательно должен находится внутри элемента `<application>`.

**Дочерние элементы:**
- `<meta-data>`
- `<grant-uri-permission>`
- `<path-permission>`

**Атрибуты:**
- `android:authorities="list"` - путь, по которому будут обращаться приложения
  для доступа к базе данных. Должен быть уникальным, поэтому рекомендуется
  использовать полное имя пакета.
- `android:directBootAware=["true" | "false"]` - включает режим **Direct Boot**,
  при котором конкретный **provider** получает ограниченный доступ к файлам сразу
  после запуска системы, но до того, как пользователь разблокирует устройство.
  Может использоваться такими приложениями, как будильники, мессенджеры.
  Подробнее в [статье](https://android-developers.googleblog.com/2016/04/developing-for-direct-boot.html "android-developers.googleblog.com") из блога Google или в
  [документации](https://developer.android.com/training/articles/direct-boot "developer.android.com").
- `android:enabled=["true" | "false"]` - если `false`, то система не может
  создавать экземпляр **provider'а**. Можно использовать для отключения **provider'ов**,
  которые не поддерживается какой-либо версией Android (хотя конкретный пример
  использования сложно представить).
- `android:exported=["true" | "false"]` - если `true`, то **provider** может
  использоваться другими приложениями, если `false` - **provider** доступен для
  компонентов одного и того же приложения, приложениям с одинаковыми
  идентификаторами пользователя, либо приложениям, которым временно предоставлен
  доступ к **provider'у** через элемент `android: grantUriPermissions`.
  Если `targetSdkVersion` 16 и ниже, то значение по умолчанию `true`, если от
  17 и выше - `false`.
- `android:grantUriPermissions=["true" | "false"]` - если `true`, то стороннему
  приложению может быть выдано временное разрешение на доступ ко всем данным
  **provider'а**. Если необходимо предоставить доступ к определенным данным, то
  задается значение `false` и добавляются элементы `<grant-uri-permission>`.
- `android:icon="drawable resource"` - иконка для текущего **provider'а**.
- `android:initOrder="integer"` - порядок запуска **provider'а** (относительно
  других **provider'ов** в одном и том же процессе). Если **provider'ы** связаны
  между собой (для работы одного требуется другой), то с помощью данного атрибута
  можно задать в какой последовательности они они будут запускаться. Причем
  наиболее высокие числа запускаются первыми.
- `android:label="string resource"` - название **provider'а**, которое отображается
  пользователю. Если не задано, то используется название, указанное в теге `<application>`.
- `android:multiprocess=["true" | "false"]` - если компоненты приложения
  работают в нескольких процессах, то с помощью данного атрибута можно указать
  будет ли создаваться отдельный экземпляр **provider'а** для каждого процесса.
  При этом значение `true` (будут создаваться) может повысить производительность,
  так как не надо будет тратить ресурсы на передачу информации между разными
  процессами, но в тоже время это увеличит объем памяти каждого процесса.
- `android:name="string"` - полное имя класса, который реализует **provider**.
- `android:permission="string"` - имя разрешения, которое должно быть
  предоставлено для чтения и записи данных **provider'а**. Атрибут будет
  игнорироваться, если заданы атрибуты `readPermission`, `writePermission`, и
  `grantUriPermissionsон`  и он им противоречит. Удобно использовать для
  добавления единого разрешения для чтения и записи данных **provider'а**.
- `android:process="string"` - позволяет указать процесс, в котором будет работать
  **provider**. По умолчанию имя процесса соответствует имени пакета, заданного в
  теге `<manifest>`. Но можно переопределить этот атрибут и распределить компоненты
  приложения по нескольким процессам.
- `android:readPermission="string"` - имя разрешения, которое должно быть
  предоставлено для чтения данных **provider'а**.
- `android:syncable=["true" | "false"]` - если `true`, то данные **provider'а**
  будут синхронизироваться с данными, хранящимися на сервере.
- `android:writePermission="string"` - имя разрешения, которое должно быть
  предоставлено для записи данных в **provider**.

***

### `<uses-library>`
Данный элемент используется в случае, когда для работы приложения необходима
библиотека, являющаяся частью прошивки устройства. Например, Goggle Карты.

Также Google Play использует этот тег для фильтра устройств, которые не
соответствуют требованиям библиотеки или у которых не установлена эта библиотека.

Данный тег обязательно должен находится внутри элемента `<application>`.

**Атрибуты:**
- `android:name="string"` - название библиотеки, берется из документации к библиотеке.
- `android:required=["true" | "false"]` - если `true`, то приложение не может
  работать без указанной библиотеки и система не даст его установить на
  устройство, где такая библиотека отсутствует.

***

### `<intent-filter>`
С помощью данного элемента можно указать типы **intent'ов**, на которые могут
реагировать компоненты приложения (activity, service, receiver). [Подробнее](https://developer.android.com/guide/components/intents-filters "developer.android.com").

**Может быть дочерним элементом для:**
- `<activity>`
- `<activity-alias>`
- `<service>`
- `<receiver>`

**Дочерние элементы:**
- `<action>` - данный элемент является обязательным.
- `<category>`
- `<data>`

**Атрибуты:**
- `android:icon="drawable resource"` - данная иконка отображается, когда
  пользователю предоставляются на выбор все компоненты (в том числе текущий),
  которые могут выполнить заданное действие.
- `android:label="string resource"` - данный заголовок отображается, когда
  пользователю предоставляются на выбор все компоненты (в том числе текущий),
  которые могут выполнить заданное действие.
- `android:priority="integer"` - задается приоритет фильтра. При выборе
  компонентов для обработки `intent`'а будет отдаваться предпочтение тем,
  у которых в данном атрибуте задано более высокое число.
- `android:order` - порядок, в котором фильтр должен обрабатываться, если он
  совпал с каким-то другим фильтром в рамках одного приложения. **_Добавлен в API 28_**.

***

### `<action>`
С помощью данного элемента для тега `<intent-filter>` задается действие, которое
могут обработать компоненты приложения. `<intent-filter>` может содержать одно
или несколько действий. Если данный элемент будет отсутствовать, то фильтр не
станет принимать объекты **Intent**.

**Атрибуты:**
- `android:name="string"` - имя действия. Стандартные действия определены в
  классе **Intent** в качестве констант. Можно создать свои действия. В этом случае
  для имени рекомендуется использовать полное имя пакета, чтобы обеспечить уникальность.

***

### `<category>`
Используется исключительно как дочерний элемент тега `<intent-filter>` и
позволяет задать ему категорию.

**Атрибуты:**
- `android:name="string"` - имя категории. Стандартные категории определены в
  классе **Intent** в качестве констант. Можно создать свои категории. В этом случае
  для имени рекомендуется использовать полное имя пакета, чтобы обеспечить уникальность.

***

### `<data>`
Используется исключительно как дочерний элемент тега `<intent-filter>`.
Объявляет тип принимаемых данных, для чего используется один или несколько
атрибутов, указывающих различные составные части URI данных (scheme, host, port,
path итд.) и тип MIME.

**Атрибуты:**
- `android:scheme="string"`
- `android:host="string"`
- `android:port="string"`
- `android:path="string"`
- `android:pathPattern="string"`
- `android:pathPrefix="string"`
- `android:mimeType="string"`

***

### `<grant-uri-permission>`
Используется исключительно как дочерний элемент тега `<provider>`.

Позволяет предоставить стороннему приложению временный доступ к данным
**provider'а**. Количество элементов не ограничено, но каждый из них должен
содержать только один путь к данным.

**Атрибуты:**
- `android:path="string"` - полный путь к данным, для которых выдается разрешение.
- `android:pathPattern="string"` - полный путь к данным, для которых выдается
  разрешение. Может содержать подстановочные знаки.
- `android:pathPrefix="string"` - путь к определенному пакету. Для всех данных в
  данном пакете будет выдано разрешение.

***

### `<path-permission>`
Используется исключительно как дочерний элемент тега `<provider>`.

Позволяет указать путь к подмножеству данных **provider'а** и необходимые
разрешения для этих данных. Может быть указан несколько раз.

**Атрибуты:**
- `android:path="string"` - полный путь к подмножеству данных. Разрешение будет
  предоставлено только указанному подмножеству.
- `android:pathPrefix="string"` - путь к определенному пакету, в котором могут
  находится подмножества данных. Разрешение будет предоставлено всем
  подмножествам в пакете.
- `android:pathPattern="string"` - с помощью данного атрибута указывается
  полный путь к подмножеству, который может содержать подстановочные знаки.
- `android:permission="string"` - имя разрешения, которое должно быть
  предоставлено для чтения или записи данных **provider'а**. Удобно использовать,
  если для чтения и записи требуется одинаковое разрешение.
- `android:readPermission="string"` - имя разрешения, которое должно быть
  предоставлено для чтения данных **provider'а**.
- `android:writePermission="string"` - имя разрешения, которое должно быть
  предоставлено для записи данных **provider'а**.

***

## Полезные ссылки

[Официальная документация](https://developer.android.com/guide/topics/manifest/manifest-intro?hl=ru "developer.android.com")
